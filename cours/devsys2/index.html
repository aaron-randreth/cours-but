<!doctype html><html lang=en><head><title>DevSys2 | Cours</title><link rel=canonical href=https://aaron-randreth.github.io/><link rel=stylesheet type=text/css href=/css/style.css><link rel=stylesheet type=text/css href=/css/nav.css><link rel=stylesheet type=text/css href=/css/footer.css><link rel=icon href=/favicon.svg type=image/svg+xml><meta name=description content="Processus en m√©moire : Programme en exe
[Stack] [ | ] [ v ] [ ] [ ] [ ] [ ^ ] [ | ] [heap ] [data ] [text ] -> stores machine code
Hi√©rarchie de la m√©moire cache -> megaoctets, rapide, ch√®re, volatile -> utile pour les operations processeurs, ralenti moins que la RAM RAM -> giga-octet, rapide, prix moyen, volatile SSD -> tera-octet, lent, non volatile, cheap Adresse logique/physique Adresse symbolique: Adresse dans le prg"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="index, follow"><meta charset=utf-8></head><body><header class=nav-header><a href=/><img class=logo src=/favicon.svg style=max-height:1.5em alt="website
     logo"></a>
<input type=checkbox id=nav-toggle class=nav-toggle><nav class=nav-top><menu><li><a href=https://aaron-randreth.github.io/>Acceuil</a></li><li><a class=active href=/cours/ title=Cours>Cours</a></li></menu></nav><label for=nav-toggle class=nav-toggle-label><span></span></label></header><main class=main-content><header><h1>DevSys2</h1></header><details class=article-info><summary>Article information</summary><section><h1>Table of content</h1><nav id=TableOfContents><ul><li><a href=#hi√©rarchie-de-la-m√©moire>Hi√©rarchie de la m√©moire</a></li><li><a href=#adresse-logiquephysique>Adresse logique/physique</a></li><li><a href=#espaces-dadressage>Espaces d&rsquo;adressage</a><ul><li><a href=#le-principe>Le principe</a></li><li><a href=#solution-originele>Solution originele</a></li><li><a href=#les-nouvelles-solutions>Les nouvelles solutions</a></li></ul></li><li><a href=#allocation-m√©moire>Allocation m√©moire</a><ul><li><a href=#strat√©gies-dallocation-continue>Strat√©gies d&rsquo;allocation continue</a></li><li><a href=#allocation-par-segementation>Allocation par segementation</a></li><li><a href=#allocation-par-pagination>Allocation par pagination</a></li><li><a href=#page--segment>Page + Segment</a></li><li><a href=#m√©moire-virtuelle>M√©moire virtuelle</a></li></ul></li></ul></nav><p>Sep 7th 2022</p><hr><p>800 mots pour 4 minutes de lecture.</p></section></details><article><p>Processus en m√©moire : Programme en exe</p><p>[Stack] [ | ] [ v ] [ ] [ ] [ ] [ ^ ] [ | ] [heap ] [data ]
[text ] -> stores machine code</p><h1 id=hi√©rarchie-de-la-m√©moire>Hi√©rarchie de la m√©moire</h1><ul><li>cache -> megaoctets, rapide, ch√®re, volatile -> utile pour les operations
processeurs, ralenti moins que la RAM</li><li>RAM -> giga-octet, rapide, prix moyen, volatile</li><li>SSD -> tera-octet, lent, non volatile, cheap</li></ul><h1 id=adresse-logiquephysique>Adresse logique/physique</h1><ul><li><p>Adresse symbolique: Adresse dans le prg</p></li><li><p>logique: g√©n√©r√©e par la CPU</p></li><li><p>physique: Adresse vue par la m√©moire et registstres d&rsquo;adresses de la meme
(base + logique = physique en mem continue)</p></li><li><p>MMU (mem management unit) fait le passage entre l&rsquo;adresse logique et la
physique</p></li></ul><p>Logique est dans le prg, pour passer de celle l√† √† la physique le CPU fait un
calcul. Comme le prg ne peut connaitre les addresses libres √† l&rsquo;√©criture, elle
abstrait cela en adresse logique, qui sont transform√© par le CPU en adresses
physiques &ldquo;r√©elles&rdquo;.</p><h1 id=espaces-dadressage>Espaces d&rsquo;adressage</h1><h2 id=le-principe>Le principe</h2><p>Pendant que des processus font des I/O, qui sont lent, le CPU travaille sur les
autres processus. Cette augmentation de vitesse introduit, l&rsquo;espace d&rsquo;adressage:
ensemble des adresses qu&rsquo;un processus peut utiliser en mem. Cela √©vite l&rsquo;acces,
l&rsquo;allocation, etc&mldr; d&rsquo;un processus sur la mem utilis√© par un autre</p><p>Avoir plusierus app en m√©moires:</p><h2 id=solution-originele>Solution originele</h2><h3 id=son-principe>son principe</h3><ul><li>Chaque proc a son propre espace d&rsquo;adressage, pour √©viter les conflits entre
eux</li><li>elle peut d√©terminer si une adresse appartient √† son espace en v√©rifiatn
qu&rsquo;elle est: pour adresse A <strong>base</strong> &lt;= A &lt; <strong>base+limite</strong></li><li>la <strong>base</strong>: plus petite adressage physique l√©gale (similaire √† la premi√®re
adresse d&rsquo;un tableau en C)</li><li>la <strong>limite (√©tendue)</strong>: taille totale de l&rsquo;espace physique auquel le proc a
acc√®s</li></ul><h3 id=ses-d√©faults>Ses d√©faults</h3><p>Cette m√©thode fonctionne si la mem physique peut contenir tous les procs, ce qui
n&rsquo;est pas le cas.</p><h2 id=les-nouvelles-solutions>Les nouvelles solutions</h2><ul><li>Segementation et/ou pagniation</li><li>virtual mem</li><li>swaping</li></ul><h1 id=allocation-m√©moire>Allocation m√©moire</h1><p>La mem physique est s√©par√©e en deux, une partie pour l&rsquo;OS et une pour les procs
utilisateurs.</p><h2 id=strat√©gies-dallocation-continue>Strat√©gies d&rsquo;allocation continue</h2><ul><li>First fit: 1er bloc libre de taille suffisante, 50% des blocs sont
inutilisables dus √† la fragmentation</li><li>Best fit: plus petit bloc libre de taille suffisante, cr√©e de nombreux espaces
mem libres inutilisables</li><li>worst fit: plus grand bloc libre</li></ul><p>L&rsquo;allocation continue m√®ne √† de la fragmentation, les zones m√©moires continues
vont laisser des espaces trop petit et inutilisables. On obtient aussi des blocs
de taille diff√©rente, ce qui rend le prog plus complexe. Une solution √† cela
consiste √† d√©placer les zones m√©moires, en les r√©allouant pour renplire les
petits espaces libres. Cela peut mener √† des freeze. L&rsquo;allocation continue reste
cenpendant une mauvaise solution.</p><h2 id=allocation-par-segementation>Allocation par segementation</h2><ul><li>Segementation: m√©chanisme permettant mappage entre l&rsquo;adresses logique et
physique.</li></ul><p>Les bouts de m√©moires avec des m√©thodes de fonctionnement diff√©rents ont des
segements diff. Un espace d&rsquo;adressage logique peut √™tre rep en un ensemble de
plusieurs seg.</p><h3 id=le-principe-1>Le principe</h3><ul><li><p>adresse logique: &lt;no. du segement, offset>, &lt;s, d></p></li><li><p>la table mappe une adresse logique (en deux dim) en une adresse physique</p></li><li><p>s: index qui pointe sur une entr√©e dans la table des segements. On obtient la
base (debut du seg) et la limite.</p></li><li><p>d: d√©placement/offset, 0 &lt;= d &lt; limite la m√©moire r√©cup√®re d + base =
physique.</p></li></ul><h3 id=ses-d√©faults-1>Ses d√©faults</h3><ul><li>fragmentation externe au segement: pas suffisament de place pour un nouveau
proc, les blocs libres ne sont pas contigus. Besoin de defrag</li></ul><h2 id=allocation-par-pagination>Allocation par pagination</h2><h3 id=le-principe-le-pb-des-outres-solutions-√©tait-ceux-de-lallocation-contigus>Le principe Le pb des outres solutions √©tait ceux de l&rsquo;allocation contigus,</h3><p>et l&rsquo;utilisation de tailles diff√©rentes.</p><p>On d√©coupe la mem physique en blocs de taille fixe, appel√©s <strong>frames</strong> (<strong>cadre
de pages</strong>). La mem logique est d√©coup√©e en blocs de m√™me taille, des <strong>pages</strong></p><h3 id=les-avantages>Les avantages</h3><h3 id=en-pratique>En pratique</h3><ul><li>adresse logique: &lt;p, d></li><li>p: num de la page</li><li>d: offset</li></ul><p>La taille de la page, et du frame, est fix√©e par le hardware. Elle est d√©finie
en puissance de 2 (pour des questions de facilit√© de calcul), elle varie entre
512o et 1GO (1024o), et d√©pends de l&rsquo;architecture de l&rsquo;ordi.</p><h2 id=page--segment>Page + Segment</h2><p>On utilise le principe de page en plus de la table des segments, qui contient
seulement l&rsquo;adresse des pages du procs.</p><p>d / T = no.page</p><h2 id=m√©moire-virtuelle>M√©moire virtuelle</h2><p>On en stocke pas les proc enti√®rement en mem, ce qui n&rsquo;est pas utilis√© est
stoqu√© sur le disque. Le proc peut donc utiliser de la mem plus grande que la
mem physique. On rajoute donc aux pages un bit pour indiquer si elle est sur la
mem centrale. Les mobiles utilisent la mem flash au lieu de la mem centrale.</p><p>On appele l&rsquo;√©change des donn√©es d&rsquo;un proc entre la mem centrale et la mem <strong>le
swap</strong>. C&rsquo;est cependant lent, et prend du CPU.</p><div id=nextprev><a href=/deveffi1/><div id=prevart>Previous:<br>D√©veloppement efficace - Introduction √† la complexit√© algorithmique</div></a><a href=/cours/proba2/><div id=nextart>Next:<br>Variables al√©atoires discr√®tes</div></a></div></article></main><footer class=end-footer><a href=#top id=top-arrow><img src=/up-arrow.svg alt=‚¨Ü style=max-height:2em title="Go to the top of the page"></a><p>Made with ‚ù§Ô∏è in
<a href=https://gohugo.io><img src=/hugo_logo.svg style=max-height:1.5em alt="hugo static site generator framework"></a></p><p>üî•Roast my source-code over at
<a href=https://github.com/aaron-randreth/aaron-randreth.github.io><img src=/github_logo.svg style=max-height:1.5em alt="hugo static site generator framework"></a></p></footer></body></html>