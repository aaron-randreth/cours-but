<!doctype html><html lang=en><head><title>DevSys4 | Cours</title><link rel=canonical href=https://aaron-randreth.github.io/><link rel=stylesheet type=text/css href=/css/style.css><link rel=stylesheet type=text/css href=/css/nav.css><link rel=stylesheet type=text/css href=/css/footer.css><link rel=icon href=/favicon.svg type=image/svg+xml><meta name=description content="Appels syst√®mes pipe: Permet √† une comande d&rsquo;envoyer des donn√©es √† un autre.
kill-signal: envoie et reception d&rsquo;un signal (le proc va regarder de regularly un tableau de signaux)
sockets: communication √† distance
Sous Unix, plusieurs procs lourds peuvent partager la m√™me zone m√©moire (pratique pour la comm inter proc, pas tr√®s utilis√©)
Fork() Cr√©e un nouveau proc via duplication, le processus p√®re est dupliqu√© et cr√©e un processus fils."><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="index, follow"><meta charset=utf-8></head><body><header class=nav-header><a href=/><img class=logo src=/favicon.svg style=max-height:1.5em alt="website
     logo"></a>
<input type=checkbox id=nav-toggle class=nav-toggle><nav class=nav-top><menu><li><a href=https://aaron-randreth.github.io/>Acceuil</a></li><li><a class=active href=/cours/ title=Cours>Cours</a></li></menu></nav><label for=nav-toggle class=nav-toggle-label><span></span></label></header><main class=main-content><header><h1>DevSys4</h1></header><details class=article-info><summary>Article information</summary><section><h1>Table of content</h1><nav id=TableOfContents><ul><li><a href=#appels-syst√®mes>Appels syst√®mes</a><ul><li><a href=#fork>Fork()</a></li><li><a href=#wait>Wait()</a></li><li><a href=#waitpid>Waitpid()</a></li><li><a href=#exec>Exec()</a></li><li><a href=#flock>Flock()</a></li></ul></li></ul></nav><p>Sep 21th 2022</p><hr><p>500 mots pour 3 minutes de lecture.</p></section></details><article><h1 id=appels-syst√®mes>Appels syst√®mes</h1><p><strong>pipe</strong>: Permet √† une comande d&rsquo;envoyer des donn√©es √† un autre.</p><p><strong>kill-signal</strong>: envoie et reception d&rsquo;un signal (le proc va regarder de
regularly un tableau de signaux)</p><p><strong>sockets</strong>: communication √† distance</p><p>Sous Unix, plusieurs procs lourds peuvent partager la m√™me zone m√©moire
(pratique pour la comm inter proc, pas tr√®s utilis√©)</p><h2 id=fork>Fork()</h2><p>Cr√©e un nouveau proc via <strong>duplication</strong>, le processus <em>p√®re</em> est dupliqu√© et cr√©e
un processus <em>fils</em>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>pid_t <span style=color:#a6e22e>fork</span>(<span style=color:#66d9ef>void</span>);
</span></span></code></pre></div><p>Cette fonction a deux valeurs de retour, elle retourne une valeur au fils et une
valeur diff√©rente au p√®re. Le p√®re obtient le pid d fils, le fils obtient 0.
Si l&rsquo;on obtient un -1, erreur de cr√©ation du fils.</p><p>Comme le fork est une duplication, on doit v√©rifier avec cette valeur de retour
si l&rsquo;onn est le p√®re ou le fils, et agir en cons√©quence.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Son propre ID
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>getpid();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Le PID du p√®re
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>getppid();
</span></span></code></pre></div><p>Comme chaque processus(sauf exception) a un seul p√®re, on peut retrouver
uniquement enregister le pid du fils dans celui du p√®re et obtenir</p><p>Comme fork est une duplication p√®re et fils partagent :</p><ul><li>le m√™me code (text)</li><li>les m√™mes descripteurs de fichiers ouverts</li><li>les m√™mes variables, mais uniquement celles d&rsquo;environment et pas les locales</li></ul><p><strong>Side note</strong>: il n&rsquo;y a pas de variables d&rsquo;environment globales i.e si l&rsquo;on
modifie/casse la valeur d&rsquo;une variables, les autres procs ne vont pas √™tre
affect√©.</p><h2 id=wait>Wait()</h2><p>Wait √©limine les procs zombies, et permet la sync d&rsquo;un processus sur la
terminaison de ses descendants avec la recup des infos relatives √† cette
terminaison.</p><p>Wait provoque la suspension du processus appelant judq&rsquo;a la fin d&rsquo;<strong>un</strong> de ses
processus fils.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/wait.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>pid_t <span style=color:#a6e22e>wait</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> status_fils);
</span></span></code></pre></div><h2 id=waitpid>Waitpid()</h2><p>Attends qu&rsquo;un fils pr√©cis se termine.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span>
</span></span><span style=display:flex><span>pid_t <span style=color:#a6e22e>Waitpid</span>(pid_t pid, <span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> status, <span style=color:#66d9ef>int</span> options);
</span></span></code></pre></div><p>Run <code>info pid</code> for more info.</p><h2 id=exec>Exec()</h2><p>La famille d&rsquo;appel <code>exec()</code> de remplacer le processus appelant par un nouveau,
avec du nouveau code, de nouvelles donn√©es, et une nouvelle pile mais les m√™mes
variables, le m√™me pid.</p><p>Il ne <strong>cr√©e pas</strong> de nouveau processus.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Path to new code source
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>execl</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> path, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> args, ...);
</span></span></code></pre></div><p><strong>Rappel</strong>: Chaque proc a dans sa table de fichiers ouverts, les 3 std (in, out, err).</p><h2 id=flock>Flock()</h2><p>Verrouillage d&rsquo;un fichier.</p><p>for more advanced info <code>info fcntl</code></p><ul><li>porte sur un descripteur de fichier.</li><li>Verrouillage du fichier en entier</li><li>verou exclusif pour ceux qui √©crivent</li><li>verrou partag√© pour ceux qui lisent</li><li>verou consultatif (un proc n&rsquo;est pas oblig√© de respecter l&rsquo;indicateur de verrou)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// info flock
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>flock</span>(<span style=color:#66d9ef>int</span> fd, <span style=color:#66d9ef>int</span> operation); 
</span></span></code></pre></div><p><strong>Note</strong>: <code>open</code> renvoie un <code>int</code> comme descripteur de fichiers, alors que <code>fopen</code> renvoie un <code>FILE*</code>.
<code>open</code> nous permet d&rsquo;utiliser <code>read</code> and <code>write</code>.</p><p><code>lockf</code> au un verrou obligatoir</p><div id=nextprev><a href=/cours/proba2/><div id=prevart>Previous:<br>Variables al√©atoires discr√®tes</div></a><a href=/cours/devsys5/><div id=nextart>Next:<br>DevSys5</div></a></div></article></main><footer class=end-footer><a href=#top id=top-arrow><img src=/up-arrow.svg alt=‚¨Ü style=max-height:2em title="Go to the top of the page"></a><p>Made with ‚ù§Ô∏è in
<a href=https://gohugo.io><img src=/hugo_logo.svg style=max-height:1.5em alt="hugo static site generator framework"></a></p><p>üî•Roast my source-code over at
<a href=https://github.com/aaron-randreth/aaron-randreth.github.io><img src=/github_logo.svg style=max-height:1.5em alt="hugo static site generator framework"></a></p></footer></body></html>